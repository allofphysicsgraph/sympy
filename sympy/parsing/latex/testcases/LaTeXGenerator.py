# Generated by Grammarinator 19.3.post111+gbab4a80.d20221219

import itertools

from math import inf
from grammarinator.runtime import *

class LaTeXGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    WS.min_depth = 0

    def THINSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='THINSPACE', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\,', '\\thinspace'][choice0], parent=current)
            return current
    THINSPACE.min_depth = 0

    def MEDSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MEDSPACE', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\:', '\\medspace'][choice0], parent=current)
            return current
    MEDSPACE.min_depth = 0

    def THICKSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='THICKSPACE', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\;', '\\thickspace'][choice0], parent=current)
            return current
    THICKSPACE.min_depth = 0

    def QUAD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='QUAD', parent=parent)) as current:
            UnlexerRule(src='\\quad', parent=current)
            return current
    QUAD.min_depth = 0

    def QQUAD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='QQUAD', parent=parent)) as current:
            UnlexerRule(src='\\qquad', parent=current)
            return current
    QQUAD.min_depth = 0

    def NEGTHINSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEGTHINSPACE', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\!', '\\negthinspace'][choice0], parent=current)
            return current
    NEGTHINSPACE.min_depth = 0

    def NEGMEDSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEGMEDSPACE', parent=parent)) as current:
            UnlexerRule(src='\\negmedspace', parent=current)
            return current
    NEGMEDSPACE.min_depth = 0

    def NEGTHICKSPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEGTHICKSPACE', parent=parent)) as current:
            UnlexerRule(src='\\negthickspace', parent=current)
            return current
    NEGTHICKSPACE.min_depth = 0

    def CMD_LEFT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_LEFT', parent=parent)) as current:
            UnlexerRule(src='\\left', parent=current)
            return current
    CMD_LEFT.min_depth = 0

    def CMD_RIGHT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_RIGHT', parent=parent)) as current:
            UnlexerRule(src='\\right', parent=current)
            return current
    CMD_RIGHT.min_depth = 0

    def IGNORE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='IGNORE', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\vrule', '\\vcenter', '\\vbox', '\\vskip', '\\vspace', '\\hfil', '\\*', '\\-', '\\.', '\\/', '\\"', '\\(', '\\='][choice0], parent=current)
            return current
    IGNORE.min_depth = 0

    def ADD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ADD', parent=parent)) as current:
            UnlexerRule(src='+', parent=current)
            return current
    ADD.min_depth = 0

    def SUB(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SUB', parent=parent)) as current:
            UnlexerRule(src='-', parent=current)
            return current
    SUB.min_depth = 0

    def MUL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MUL', parent=parent)) as current:
            UnlexerRule(src='*', parent=current)
            return current
    MUL.min_depth = 0

    def DIV(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIV', parent=parent)) as current:
            UnlexerRule(src='/', parent=current)
            return current
    DIV.min_depth = 0

    def L_PAREN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_PAREN', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            return current
    L_PAREN.min_depth = 0

    def R_PAREN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_PAREN', parent=parent)) as current:
            UnlexerRule(src=')', parent=current)
            return current
    R_PAREN.min_depth = 0

    def L_BRACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_BRACE', parent=parent)) as current:
            UnlexerRule(src='{', parent=current)
            return current
    L_BRACE.min_depth = 0

    def R_BRACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_BRACE', parent=parent)) as current:
            UnlexerRule(src='}', parent=current)
            return current
    R_BRACE.min_depth = 0

    def L_BRACE_LITERAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_BRACE_LITERAL', parent=parent)) as current:
            UnlexerRule(src='\\{', parent=current)
            return current
    L_BRACE_LITERAL.min_depth = 0

    def R_BRACE_LITERAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_BRACE_LITERAL', parent=parent)) as current:
            UnlexerRule(src='\\}', parent=current)
            return current
    R_BRACE_LITERAL.min_depth = 0

    def L_BRACKET(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_BRACKET', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            return current
    L_BRACKET.min_depth = 0

    def R_BRACKET(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_BRACKET', parent=parent)) as current:
            UnlexerRule(src=']', parent=current)
            return current
    R_BRACKET.min_depth = 0

    def BAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BAR', parent=parent)) as current:
            UnlexerRule(src='|', parent=current)
            return current
    BAR.min_depth = 0

    def R_BAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_BAR', parent=parent)) as current:
            UnlexerRule(src='\\right|', parent=current)
            return current
    R_BAR.min_depth = 0

    def L_BAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_BAR', parent=parent)) as current:
            UnlexerRule(src='\\left|', parent=current)
            return current
    L_BAR.min_depth = 0

    def L_ANGLE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_ANGLE', parent=parent)) as current:
            UnlexerRule(src='\\langle', parent=current)
            return current
    L_ANGLE.min_depth = 0

    def R_ANGLE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_ANGLE', parent=parent)) as current:
            UnlexerRule(src='\\rangle', parent=current)
            return current
    R_ANGLE.min_depth = 0

    def FUNC_LIM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_LIM', parent=parent)) as current:
            UnlexerRule(src='\\lim', parent=current)
            return current
    FUNC_LIM.min_depth = 0

    def LIM_APPROACH_SYM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LIM_APPROACH_SYM', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\to', '\\rightarrow', '\\Rightarrow', '\\longrightarrow', '\\Longrightarrow'][choice0], parent=current)
            return current
    LIM_APPROACH_SYM.min_depth = 0

    def FUNC_INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_INT', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\int', '\\int\\limits'][choice0], parent=current)
            return current
    FUNC_INT.min_depth = 0

    def FUNC_SUM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_SUM', parent=parent)) as current:
            UnlexerRule(src='\\sum', parent=current)
            return current
    FUNC_SUM.min_depth = 0

    def FUNC_PROD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_PROD', parent=parent)) as current:
            UnlexerRule(src='\\prod', parent=current)
            return current
    FUNC_PROD.min_depth = 0

    def FUNC_EXP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_EXP', parent=parent)) as current:
            UnlexerRule(src='\\exp', parent=current)
            return current
    FUNC_EXP.min_depth = 0

    def FUNC_LOG(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_LOG', parent=parent)) as current:
            UnlexerRule(src='\\log', parent=current)
            return current
    FUNC_LOG.min_depth = 0

    def FUNC_LG(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_LG', parent=parent)) as current:
            UnlexerRule(src='\\lg', parent=current)
            return current
    FUNC_LG.min_depth = 0

    def FUNC_LN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_LN', parent=parent)) as current:
            UnlexerRule(src='\\ln', parent=current)
            return current
    FUNC_LN.min_depth = 0

    def FUNC_SIN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_SIN', parent=parent)) as current:
            UnlexerRule(src='\\sin', parent=current)
            return current
    FUNC_SIN.min_depth = 0

    def FUNC_COS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_COS', parent=parent)) as current:
            UnlexerRule(src='\\cos', parent=current)
            return current
    FUNC_COS.min_depth = 0

    def FUNC_TAN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_TAN', parent=parent)) as current:
            UnlexerRule(src='\\tan', parent=current)
            return current
    FUNC_TAN.min_depth = 0

    def FUNC_CSC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_CSC', parent=parent)) as current:
            UnlexerRule(src='\\csc', parent=current)
            return current
    FUNC_CSC.min_depth = 0

    def FUNC_SEC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_SEC', parent=parent)) as current:
            UnlexerRule(src='\\sec', parent=current)
            return current
    FUNC_SEC.min_depth = 0

    def FUNC_COT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_COT', parent=parent)) as current:
            UnlexerRule(src='\\cot', parent=current)
            return current
    FUNC_COT.min_depth = 0

    def FUNC_ARCSIN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCSIN', parent=parent)) as current:
            UnlexerRule(src='\\arcsin', parent=current)
            return current
    FUNC_ARCSIN.min_depth = 0

    def FUNC_ARCCOS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCCOS', parent=parent)) as current:
            UnlexerRule(src='\\arccos', parent=current)
            return current
    FUNC_ARCCOS.min_depth = 0

    def FUNC_ARCTAN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCTAN', parent=parent)) as current:
            UnlexerRule(src='\\arctan', parent=current)
            return current
    FUNC_ARCTAN.min_depth = 0

    def FUNC_ARCCSC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCCSC', parent=parent)) as current:
            UnlexerRule(src='\\arccsc', parent=current)
            return current
    FUNC_ARCCSC.min_depth = 0

    def FUNC_ARCSEC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCSEC', parent=parent)) as current:
            UnlexerRule(src='\\arcsec', parent=current)
            return current
    FUNC_ARCSEC.min_depth = 0

    def FUNC_ARCCOT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCCOT', parent=parent)) as current:
            UnlexerRule(src='\\arccot', parent=current)
            return current
    FUNC_ARCCOT.min_depth = 0

    def FUNC_SINH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_SINH', parent=parent)) as current:
            UnlexerRule(src='\\sinh', parent=current)
            return current
    FUNC_SINH.min_depth = 0

    def FUNC_COSH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_COSH', parent=parent)) as current:
            UnlexerRule(src='\\cosh', parent=current)
            return current
    FUNC_COSH.min_depth = 0

    def FUNC_TANH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_TANH', parent=parent)) as current:
            UnlexerRule(src='\\tanh', parent=current)
            return current
    FUNC_TANH.min_depth = 0

    def FUNC_ARSINH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARSINH', parent=parent)) as current:
            UnlexerRule(src='\\arsinh', parent=current)
            return current
    FUNC_ARSINH.min_depth = 0

    def FUNC_ARCOSH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARCOSH', parent=parent)) as current:
            UnlexerRule(src='\\arcosh', parent=current)
            return current
    FUNC_ARCOSH.min_depth = 0

    def FUNC_ARTANH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_ARTANH', parent=parent)) as current:
            UnlexerRule(src='\\artanh', parent=current)
            return current
    FUNC_ARTANH.min_depth = 0

    def L_FLOOR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_FLOOR', parent=parent)) as current:
            UnlexerRule(src='\\lfloor', parent=current)
            return current
    L_FLOOR.min_depth = 0

    def R_FLOOR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_FLOOR', parent=parent)) as current:
            UnlexerRule(src='\\rfloor', parent=current)
            return current
    R_FLOOR.min_depth = 0

    def L_CEIL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_CEIL', parent=parent)) as current:
            UnlexerRule(src='\\lceil', parent=current)
            return current
    L_CEIL.min_depth = 0

    def R_CEIL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='R_CEIL', parent=parent)) as current:
            UnlexerRule(src='\\rceil', parent=current)
            return current
    R_CEIL.min_depth = 0

    def FUNC_SQRT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_SQRT', parent=parent)) as current:
            UnlexerRule(src='\\sqrt', parent=current)
            return current
    FUNC_SQRT.min_depth = 0

    def FUNC_OVERLINE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNC_OVERLINE', parent=parent)) as current:
            UnlexerRule(src='\\overline', parent=current)
            return current
    FUNC_OVERLINE.min_depth = 0

    def CMD_TIMES(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_TIMES', parent=parent)) as current:
            UnlexerRule(src='\\times', parent=current)
            return current
    CMD_TIMES.min_depth = 0

    def CMD_CDOT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_CDOT', parent=parent)) as current:
            UnlexerRule(src='\\cdot', parent=current)
            return current
    CMD_CDOT.min_depth = 0

    def CMD_DIV(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_DIV', parent=parent)) as current:
            UnlexerRule(src='\\div', parent=current)
            return current
    CMD_DIV.min_depth = 0

    def CMD_FRAC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_FRAC', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['\\frac', '\\dfrac', '\\tfrac'][choice0], parent=current)
            return current
    CMD_FRAC.min_depth = 0

    def CMD_BINOM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_BINOM', parent=parent)) as current:
            UnlexerRule(src='\\binom', parent=current)
            return current
    CMD_BINOM.min_depth = 0

    def CMD_DBINOM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_DBINOM', parent=parent)) as current:
            UnlexerRule(src='\\dbinom', parent=current)
            return current
    CMD_DBINOM.min_depth = 0

    def CMD_TBINOM(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_TBINOM', parent=parent)) as current:
            UnlexerRule(src='\\tbinom', parent=current)
            return current
    CMD_TBINOM.min_depth = 0

    def CMD_MATHIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CMD_MATHIT', parent=parent)) as current:
            UnlexerRule(src='\\mathit', parent=current)
            return current
    CMD_MATHIT.min_depth = 0

    def UNDERSCORE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='UNDERSCORE', parent=parent)) as current:
            UnlexerRule(src='_', parent=current)
            return current
    UNDERSCORE.min_depth = 0

    def CARET(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CARET', parent=parent)) as current:
            UnlexerRule(src='^', parent=current)
            return current
    CARET.min_depth = 0

    def COLON(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COLON', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            return current
    COLON.min_depth = 0

    def WS_CHAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS_CHAR', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            return current
    WS_CHAR.min_depth = 0

    def DIFFERENTIAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIFFERENTIAL', parent=parent)) as current:
            UnlexerRule(src='d', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.WS_CHAR(parent=current)
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='\\', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=1, max=inf):
                            UnlexerRule(src=self._model.charset(current, 1, self._charsets[4]), parent=current)
            return current
    DIFFERENTIAL.min_depth = 0

    def LETTER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LETTER', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[5]), parent=current)
            return current
    LETTER.min_depth = 0

    def DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIGIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[6]), parent=current)
            return current
    DIGIT.min_depth = 0

    def EQUAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EQUAL', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            UnlexerRule(src='&', parent=current)
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 1, min=0, max=inf):
                                    self.WS_CHAR(parent=current)
                    UnlexerRule(src='=', parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='=', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 3, min=0, max=inf):
                                    self.WS_CHAR(parent=current)
                            UnlexerRule(src='&', parent=current)
            return current
    EQUAL.min_depth = 0

    def NEQ(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEQ', parent=parent)) as current:
            UnlexerRule(src='\\neq', parent=current)
            return current
    NEQ.min_depth = 0

    def LT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LT', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            return current
    LT.min_depth = 0

    def LTE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LTE', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 1, 1], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = ['\\leq', '\\le', None, None][choice0]
                rule = [None, None, self.LTE_Q, self.LTE_S][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    LTE.min_depth = 0

    def LTE_Q(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LTE_Q', parent=parent)) as current:
            UnlexerRule(src='\\leqq', parent=current)
            return current
    LTE_Q.min_depth = 0

    def LTE_S(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LTE_S', parent=parent)) as current:
            UnlexerRule(src='\\leqslant', parent=current)
            return current
    LTE_S.min_depth = 0

    def GT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GT', parent=parent)) as current:
            UnlexerRule(src='>', parent=current)
            return current
    GT.min_depth = 0

    def GTE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GTE', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 1, 1], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = ['\\geq', '\\ge', None, None][choice0]
                rule = [None, None, self.GTE_Q, self.GTE_S][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    GTE.min_depth = 0

    def GTE_Q(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GTE_Q', parent=parent)) as current:
            UnlexerRule(src='\\geqq', parent=current)
            return current
    GTE_Q.min_depth = 0

    def GTE_S(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GTE_S', parent=parent)) as current:
            UnlexerRule(src='\\geqslant', parent=current)
            return current
    GTE_S.min_depth = 0

    def BANG(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BANG', parent=parent)) as current:
            UnlexerRule(src='!', parent=current)
            return current
    BANG.min_depth = 0

    def SINGLE_QUOTES(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SINGLE_QUOTES', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src='\'', parent=current)
            return current
    SINGLE_QUOTES.min_depth = 0

    def SYMBOL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SYMBOL', parent=parent)) as current:
            UnlexerRule(src='\\', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[7]), parent=current)
            return current
    SYMBOL.min_depth = 0

    def math(self, parent=None):
        with RuleContext(self, UnparserRule(name='math', parent=parent)) as current:
            self.relation(parent=current)
            return current
    math.min_depth = 10

    def relation(self, parent=None):
        with RuleContext(self, UnparserRule(name='relation', parent=parent)) as current:
            with AlternationContext(self, [10, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.relation(parent=current)
                    with AlternationContext(self, [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.EQUAL, self.LT, self.LTE, self.GT, self.GTE, self.NEQ][choice1](parent=current)
                    self.relation(parent=current)
                elif choice0 == 1:
                    self.expr(parent=current)
            return current
    relation.min_depth = 9

    def equality(self, parent=None):
        with RuleContext(self, UnparserRule(name='equality', parent=parent)) as current:
            self.expr(parent=current)
            self.EQUAL(parent=current)
            self.expr(parent=current)
            return current
    equality.min_depth = 9

    def expr(self, parent=None):
        with RuleContext(self, UnparserRule(name='expr', parent=parent)) as current:
            self.additive(parent=current)
            return current
    expr.min_depth = 8

    def additive(self, parent=None):
        with RuleContext(self, UnparserRule(name='additive', parent=parent)) as current:
            with AlternationContext(self, [8, 7], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.additive(parent=current)
                    with AlternationContext(self, [1, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.ADD, self.SUB][choice1](parent=current)
                    self.additive(parent=current)
                elif choice0 == 1:
                    self.mp(parent=current)
            return current
    additive.min_depth = 7

    def mp(self, parent=None):
        with RuleContext(self, UnparserRule(name='mp', parent=parent)) as current:
            with AlternationContext(self, [7, 6], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.mp(parent=current)
                    with AlternationContext(self, [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.MUL, self.CMD_TIMES, self.CMD_CDOT, self.DIV, self.CMD_DIV, self.COLON][choice1](parent=current)
                    self.mp(parent=current)
                elif choice0 == 1:
                    self.unary(parent=current)
            return current
    mp.min_depth = 6

    def mp_nofunc(self, parent=None):
        with RuleContext(self, UnparserRule(name='mp_nofunc', parent=parent)) as current:
            with AlternationContext(self, [7, 6], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.mp_nofunc(parent=current)
                    with AlternationContext(self, [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.MUL, self.CMD_TIMES, self.CMD_CDOT, self.DIV, self.CMD_DIV, self.COLON][choice1](parent=current)
                    self.mp_nofunc(parent=current)
                elif choice0 == 1:
                    self.unary_nofunc(parent=current)
            return current
    mp_nofunc.min_depth = 6

    def unary(self, parent=None):
        with RuleContext(self, UnparserRule(name='unary', parent=parent)) as current:
            with AlternationContext(self, [6, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.ADD, self.SUB][choice1](parent=current)
                    self.unary(parent=current)
                elif choice0 == 1:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.postfix(parent=current)
            return current
    unary.min_depth = 5

    def unary_nofunc(self, parent=None):
        with RuleContext(self, UnparserRule(name='unary_nofunc', parent=parent)) as current:
            with AlternationContext(self, [6, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.ADD, self.SUB][choice1](parent=current)
                    self.unary_nofunc(parent=current)
                elif choice0 == 1:
                    self.postfix(parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            self.postfix_nofunc(parent=current)
            return current
    unary_nofunc.min_depth = 5

    def postfix(self, parent=None):
        with RuleContext(self, UnparserRule(name='postfix', parent=parent)) as current:
            self.exp(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.postfix_op(parent=current)
            return current
    postfix.min_depth = 4

    def postfix_nofunc(self, parent=None):
        with RuleContext(self, UnparserRule(name='postfix_nofunc', parent=parent)) as current:
            self.exp_nofunc(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.postfix_op(parent=current)
            return current
    postfix_nofunc.min_depth = 4

    def postfix_op(self, parent=None):
        with RuleContext(self, UnparserRule(name='postfix_op', parent=parent)) as current:
            with AlternationContext(self, [1, 11], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.BANG, self.eval_at][choice0](parent=current)
            return current
    postfix_op.min_depth = 1

    def eval_at(self, parent=None):
        with RuleContext(self, UnparserRule(name='eval_at', parent=parent)) as current:
            self.BAR(parent=current)
            with AlternationContext(self, [10, 10, 10], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.eval_at_sup(parent=current)
                elif choice0 == 1:
                    self.eval_at_sub(parent=current)
                elif choice0 == 2:
                    self.eval_at_sup(parent=current)
                    self.eval_at_sub(parent=current)
            return current
    eval_at.min_depth = 10

    def eval_at_sub(self, parent=None):
        with RuleContext(self, UnparserRule(name='eval_at_sub', parent=parent)) as current:
            self.UNDERSCORE(parent=current)
            self.L_BRACE(parent=current)
            with AlternationContext(self, [9, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.expr, self.equality][choice0](parent=current)
            self.R_BRACE(parent=current)
            return current
    eval_at_sub.min_depth = 9

    def eval_at_sup(self, parent=None):
        with RuleContext(self, UnparserRule(name='eval_at_sup', parent=parent)) as current:
            self.CARET(parent=current)
            self.L_BRACE(parent=current)
            with AlternationContext(self, [9, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.expr, self.equality][choice0](parent=current)
            self.R_BRACE(parent=current)
            return current
    eval_at_sup.min_depth = 9

    def exp(self, parent=None):
        with RuleContext(self, UnparserRule(name='exp', parent=parent)) as current:
            with AlternationContext(self, [4, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.exp(parent=current)
                    self.CARET(parent=current)
                    with AlternationContext(self, [2, 9], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        if choice1 == 0:
                            self.atom(parent=current)
                        elif choice1 == 1:
                            self.L_BRACE(parent=current)
                            self.expr(parent=current)
                            self.R_BRACE(parent=current)
                    if self._max_depth >= 3:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.subexpr(parent=current)
                elif choice0 == 1:
                    self.comp(parent=current)
            return current
    exp.min_depth = 3

    def exp_nofunc(self, parent=None):
        with RuleContext(self, UnparserRule(name='exp_nofunc', parent=parent)) as current:
            with AlternationContext(self, [4, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.exp_nofunc(parent=current)
                    self.CARET(parent=current)
                    with AlternationContext(self, [2, 9], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        if choice1 == 0:
                            self.atom(parent=current)
                        elif choice1 == 1:
                            self.L_BRACE(parent=current)
                            self.expr(parent=current)
                            self.R_BRACE(parent=current)
                    if self._max_depth >= 3:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.subexpr(parent=current)
                elif choice0 == 1:
                    self.comp_nofunc(parent=current)
            return current
    exp_nofunc.min_depth = 3

    def comp(self, parent=None):
        with RuleContext(self, UnparserRule(name='comp', parent=parent)) as current:
            with AlternationContext(self, [10, 10, 2, 2, 10, 10], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.group, self.abs_group, self.func, self.atom, self.floor, self.ceil][choice0](parent=current)
            return current
    comp.min_depth = 2

    def comp_nofunc(self, parent=None):
        with RuleContext(self, UnparserRule(name='comp_nofunc', parent=parent)) as current:
            with AlternationContext(self, [10, 10, 2, 10, 10], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.group, self.abs_group, self.atom, self.floor, self.ceil][choice0](parent=current)
            return current
    comp_nofunc.min_depth = 2

    def group(self, parent=None):
        with RuleContext(self, UnparserRule(name='group', parent=parent)) as current:
            with AlternationContext(self, [9, 9, 9, 9], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.L_PAREN(parent=current)
                    self.expr(parent=current)
                    self.R_PAREN(parent=current)
                elif choice0 == 1:
                    self.L_BRACKET(parent=current)
                    self.expr(parent=current)
                    self.R_BRACKET(parent=current)
                elif choice0 == 2:
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    self.R_BRACE(parent=current)
                elif choice0 == 3:
                    self.L_BRACE_LITERAL(parent=current)
                    self.expr(parent=current)
                    self.R_BRACE_LITERAL(parent=current)
            return current
    group.min_depth = 9

    def abs_group(self, parent=None):
        with RuleContext(self, UnparserRule(name='abs_group', parent=parent)) as current:
            self.BAR(parent=current)
            self.expr(parent=current)
            self.BAR(parent=current)
            return current
    abs_group.min_depth = 9

    def number(self, parent=None):
        with RuleContext(self, UnparserRule(name='number', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.DIGIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.DIGIT(parent=current)
                    self.DIGIT(parent=current)
                    self.DIGIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 2, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                            self.DIGIT(parent=current)
            return current
    number.min_depth = 1

    def atom(self, parent=None):
        with RuleContext(self, UnparserRule(name='atom', parent=parent)) as current:
            with AlternationContext(self, [1, 2, 1, 2, 2, 10, 10, 10], [1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.LETTER, self.SYMBOL][choice1](parent=current)
                    with AlternationContext(self, [0, 0], [1, 1]) as weights2:
                        choice2 = self._model.choice(current, 2, weights2)
                        if choice2 == 0:
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 0, min=0, max=1):
                                    self.subexpr(parent=current)
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 1, min=0, max=1):
                                    self.SINGLE_QUOTES(parent=current)
                        elif choice2 == 1:
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 2, min=0, max=1):
                                    self.SINGLE_QUOTES(parent=current)
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 3, min=0, max=1):
                                    self.subexpr(parent=current)
                elif choice0 == 1:
                    self.number(parent=current)
                elif choice0 == 2:
                    self.DIFFERENTIAL(parent=current)
                elif choice0 == 3:
                    self.mathit(parent=current)
                elif choice0 == 4:
                    self.frac(parent=current)
                elif choice0 == 5:
                    self.binom(parent=current)
                elif choice0 == 6:
                    self.bra(parent=current)
                elif choice0 == 7:
                    self.ket(parent=current)
            return current
    atom.min_depth = 1

    def bra(self, parent=None):
        with RuleContext(self, UnparserRule(name='bra', parent=parent)) as current:
            self.L_ANGLE(parent=current)
            self.expr(parent=current)
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.R_BAR, self.BAR][choice0](parent=current)
            return current
    bra.min_depth = 9

    def ket(self, parent=None):
        with RuleContext(self, UnparserRule(name='ket', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.L_BAR, self.BAR][choice0](parent=current)
            self.expr(parent=current)
            self.R_ANGLE(parent=current)
            return current
    ket.min_depth = 9

    def mathit(self, parent=None):
        with RuleContext(self, UnparserRule(name='mathit', parent=parent)) as current:
            self.CMD_MATHIT(parent=current)
            self.L_BRACE(parent=current)
            self.mathit_text(parent=current)
            self.R_BRACE(parent=current)
            return current
    mathit.min_depth = 1

    def mathit_text(self, parent=None):
        with RuleContext(self, UnparserRule(name='mathit_text', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.LETTER(parent=current)
            return current
    mathit_text.min_depth = 0

    def frac(self, parent=None):
        local_ctx = dict()
        with RuleContext(self, UnparserRule(name='frac', parent=parent)) as current:
            self.CMD_FRAC(parent=current)
            with AlternationContext(self, [1, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.DIGIT(parent=current)
                    local_ctx['upperd'] = current.last_child
                elif choice0 == 1:
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    local_ctx['upper'] = current.last_child
                    self.R_BRACE(parent=current)
            with AlternationContext(self, [1, 9], [1, 1]) as weights1:
                choice1 = self._model.choice(current, 1, weights1)
                if choice1 == 0:
                    self.DIGIT(parent=current)
                    local_ctx['lowerd'] = current.last_child
                elif choice1 == 1:
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    local_ctx['lower'] = current.last_child
                    self.R_BRACE(parent=current)
            return current
    frac.min_depth = 1

    def binom(self, parent=None):
        local_ctx = dict()
        with RuleContext(self, UnparserRule(name='binom', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.CMD_BINOM, self.CMD_DBINOM, self.CMD_TBINOM][choice0](parent=current)
            self.L_BRACE(parent=current)
            self.expr(parent=current)
            local_ctx['n'] = current.last_child
            self.R_BRACE(parent=current)
            self.L_BRACE(parent=current)
            self.expr(parent=current)
            local_ctx['k'] = current.last_child
            self.R_BRACE(parent=current)
            return current
    binom.min_depth = 9

    def floor(self, parent=None):
        local_ctx = dict()
        with RuleContext(self, UnparserRule(name='floor', parent=parent)) as current:
            self.L_FLOOR(parent=current)
            self.expr(parent=current)
            local_ctx['val'] = current.last_child
            self.R_FLOOR(parent=current)
            return current
    floor.min_depth = 9

    def ceil(self, parent=None):
        local_ctx = dict()
        with RuleContext(self, UnparserRule(name='ceil', parent=parent)) as current:
            self.L_CEIL(parent=current)
            self.expr(parent=current)
            local_ctx['val'] = current.last_child
            self.R_CEIL(parent=current)
            return current
    ceil.min_depth = 9

    def func_normal(self, parent=None):
        with RuleContext(self, UnparserRule(name='func_normal', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.FUNC_EXP, self.FUNC_LOG, self.FUNC_LG, self.FUNC_LN, self.FUNC_SIN, self.FUNC_COS, self.FUNC_TAN, self.FUNC_CSC, self.FUNC_SEC, self.FUNC_COT, self.FUNC_ARCSIN, self.FUNC_ARCCOS, self.FUNC_ARCTAN, self.FUNC_ARCCSC, self.FUNC_ARCSEC, self.FUNC_ARCCOT, self.FUNC_SINH, self.FUNC_COSH, self.FUNC_TANH, self.FUNC_ARSINH, self.FUNC_ARCOSH, self.FUNC_ARTANH][choice0](parent=current)
            return current
    func_normal.min_depth = 1

    def func(self, parent=None):
        local_ctx = dict()
        with RuleContext(self, UnparserRule(name='func', parent=parent)) as current:
            with AlternationContext(self, [8, 10, 1, 9, 9, 11, 10], [1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.func_normal(parent=current)
                    with AlternationContext(self, [0, 0], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        if choice1 == 0:
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 0, min=0, max=1):
                                    self.subexpr(parent=current)
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 1, min=0, max=1):
                                    self.supexpr(parent=current)
                        elif choice1 == 1:
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 2, min=0, max=1):
                                    self.supexpr(parent=current)
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 3, min=0, max=1):
                                    self.subexpr(parent=current)
                    with AlternationContext(self, [10, 8], [1, 1]) as weights2:
                        choice2 = self._model.choice(current, 2, weights2)
                        if choice2 == 0:
                            self.L_PAREN(parent=current)
                            self.func_arg(parent=current)
                            self.R_PAREN(parent=current)
                        elif choice2 == 1:
                            self.func_arg_noparens(parent=current)
                elif choice0 == 1:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights3:
                        choice3 = self._model.choice(current, 3, weights3)
                        [self.LETTER, self.SYMBOL][choice3](parent=current)
                    with AlternationContext(self, [0, 0], [1, 1]) as weights4:
                        choice4 = self._model.choice(current, 4, weights4)
                        if choice4 == 0:
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 4, min=0, max=1):
                                    self.subexpr(parent=current)
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 5, min=0, max=1):
                                    self.SINGLE_QUOTES(parent=current)
                        elif choice4 == 1:
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 6, min=0, max=1):
                                    self.SINGLE_QUOTES(parent=current)
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 7, min=0, max=1):
                                    self.subexpr(parent=current)
                    self.L_PAREN(parent=current)
                    self.args(parent=current)
                    self.R_PAREN(parent=current)
                elif choice0 == 2:
                    self.FUNC_INT(parent=current)
                    if self._max_depth >= 3:
                        for _ in self._model.quantify(current, 8, min=0, max=1):
                            with AlternationContext(self, [3, 3], [1, 1]) as weights5:
                                choice5 = self._model.choice(current, 5, weights5)
                                if choice5 == 0:
                                    self.subexpr(parent=current)
                                    self.supexpr(parent=current)
                                elif choice5 == 1:
                                    self.supexpr(parent=current)
                                    self.subexpr(parent=current)
                    with AlternationContext(self, [1, 2, 8], [1, 1, 1]) as weights6:
                        choice6 = self._model.choice(current, 6, weights6)
                        if choice6 == 0:
                            if self._max_depth >= 8:
                                for _ in self._model.quantify(current, 9, min=0, max=1):
                                    self.additive(parent=current)
                            self.DIFFERENTIAL(parent=current)
                        elif choice6 == 1:
                            self.frac(parent=current)
                        elif choice6 == 2:
                            self.additive(parent=current)
                elif choice0 == 3:
                    self.FUNC_SQRT(parent=current)
                    if self._max_depth >= 9:
                        for _ in self._model.quantify(current, 10, min=0, max=1):
                            self.L_BRACKET(parent=current)
                            self.expr(parent=current)
                            local_ctx['root'] = current.last_child
                            self.R_BRACKET(parent=current)
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    local_ctx['base'] = current.last_child
                    self.R_BRACE(parent=current)
                elif choice0 == 4:
                    self.FUNC_OVERLINE(parent=current)
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    local_ctx['base'] = current.last_child
                    self.R_BRACE(parent=current)
                elif choice0 == 5:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights7:
                        choice7 = self._model.choice(current, 7, weights7)
                        [self.FUNC_SUM, self.FUNC_PROD][choice7](parent=current)
                    with AlternationContext(self, [11, 11], [1, 1]) as weights8:
                        choice8 = self._model.choice(current, 8, weights8)
                        if choice8 == 0:
                            self.subeq(parent=current)
                            self.supexpr(parent=current)
                        elif choice8 == 1:
                            self.supexpr(parent=current)
                            self.subeq(parent=current)
                    self.mp(parent=current)
                elif choice0 == 6:
                    self.FUNC_LIM(parent=current)
                    self.limit_sub(parent=current)
                    self.mp(parent=current)
            return current
    func.min_depth = 1

    def args(self, parent=None):
        with RuleContext(self, UnparserRule(name='args', parent=parent)) as current:
            with AlternationContext(self, [10, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.expr(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.args(parent=current)
                elif choice0 == 1:
                    self.expr(parent=current)
            return current
    args.min_depth = 9

    def limit_sub(self, parent=None):
        with RuleContext(self, UnparserRule(name='limit_sub', parent=parent)) as current:
            self.UNDERSCORE(parent=current)
            self.L_BRACE(parent=current)
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.LETTER, self.SYMBOL][choice0](parent=current)
            self.LIM_APPROACH_SYM(parent=current)
            self.expr(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.CARET(parent=current)
                    with AlternationContext(self, [1, 1, 1], [1, 1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        if choice1 == 0:
                            self.L_BRACE(parent=current)
                            with AlternationContext(self, [1, 1], [1, 1]) as weights2:
                                choice2 = self._model.choice(current, 2, weights2)
                                [self.ADD, self.SUB][choice2](parent=current)
                            self.R_BRACE(parent=current)
                        elif choice1 == 1:
                            self.ADD(parent=current)
                        elif choice1 == 2:
                            self.SUB(parent=current)
            self.R_BRACE(parent=current)
            return current
    limit_sub.min_depth = 9

    def func_arg(self, parent=None):
        with RuleContext(self, UnparserRule(name='func_arg', parent=parent)) as current:
            with AlternationContext(self, [9, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.expr(parent=current)
                elif choice0 == 1:
                    self.expr(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.func_arg(parent=current)
            return current
    func_arg.min_depth = 9

    def func_arg_noparens(self, parent=None):
        with RuleContext(self, UnparserRule(name='func_arg_noparens', parent=parent)) as current:
            self.mp_nofunc(parent=current)
            return current
    func_arg_noparens.min_depth = 7

    def subexpr(self, parent=None):
        with RuleContext(self, UnparserRule(name='subexpr', parent=parent)) as current:
            self.UNDERSCORE(parent=current)
            with AlternationContext(self, [2, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.atom(parent=current)
                elif choice0 == 1:
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    self.R_BRACE(parent=current)
            return current
    subexpr.min_depth = 2

    def supexpr(self, parent=None):
        with RuleContext(self, UnparserRule(name='supexpr', parent=parent)) as current:
            self.CARET(parent=current)
            with AlternationContext(self, [2, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.atom(parent=current)
                elif choice0 == 1:
                    self.L_BRACE(parent=current)
                    self.expr(parent=current)
                    self.R_BRACE(parent=current)
            return current
    supexpr.min_depth = 2

    def subeq(self, parent=None):
        with RuleContext(self, UnparserRule(name='subeq', parent=parent)) as current:
            self.UNDERSCORE(parent=current)
            self.L_BRACE(parent=current)
            self.equality(parent=current)
            self.R_BRACE(parent=current)
            return current
    subeq.min_depth = 10

    def supeq(self, parent=None):
        with RuleContext(self, UnparserRule(name='supeq', parent=parent)) as current:
            self.UNDERSCORE(parent=current)
            self.L_BRACE(parent=current)
            self.equality(parent=current)
            self.R_BRACE(parent=current)
            return current
    supeq.min_depth = 10

    _default_rule = WS

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
        2: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
        3: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
        4: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
        5: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
        6: list(itertools.chain.from_iterable([range(48, 58)])),
        7: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
    }
